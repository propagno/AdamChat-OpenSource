{"ast":null,"code":"/**\n * @import {Handle, Info, State} from 'mdast-util-to-markdown'\n * @import {PhrasingParents} from '../types.js'\n */\n\nimport { encodeCharacterReference } from './encode-character-reference.js';\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @param {PhrasingParents} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nexport function containerPhrasing(parent, state, info) {\n  const indexStack = state.indexStack;\n  const children = parent.children || [];\n  /** @type {Array<string>} */\n  const results = [];\n  let index = -1;\n  let before = info.before;\n  /** @type {string | undefined} */\n  let encodeAfter;\n  indexStack.push(-1);\n  let tracker = state.createTracker(info);\n  while (++index < children.length) {\n    const child = children[index];\n    /** @type {string} */\n    let after;\n    indexStack[indexStack.length - 1] = index;\n    if (index + 1 < children.length) {\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      let handle = state.handle.handlers[children[index + 1].type];\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      if (handle && handle.peek) handle = handle.peek;\n      after = handle ? handle(children[index + 1], parent, state, {\n        before: '',\n        after: '',\n        ...tracker.current()\n      }).charAt(0) : '';\n    } else {\n      after = info.after;\n    }\n\n    // In some cases, html (text) can be found in phrasing right after an eol.\n    // When we’d serialize that, in most cases that would be seen as html\n    // (flow).\n    // As we can’t escape or so to prevent it from happening, we take a somewhat\n    // reasonable approach: replace that eol with a space.\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\n    if (results.length > 0 && (before === '\\r' || before === '\\n') && child.type === 'html') {\n      results[results.length - 1] = results[results.length - 1].replace(/(\\r?\\n|\\r)$/, ' ');\n      before = ' ';\n\n      // To do: does this work to reset tracker?\n      tracker = state.createTracker(info);\n      tracker.move(results.join(''));\n    }\n    let value = state.handle(child, parent, state, {\n      ...tracker.current(),\n      after,\n      before\n    });\n\n    // If we had to encode the first character after the previous node and it’s\n    // still the same character,\n    // encode it.\n    if (encodeAfter && encodeAfter === value.slice(0, 1)) {\n      value = encodeCharacterReference(encodeAfter.charCodeAt(0)) + value.slice(1);\n    }\n    const encodingInfo = state.attentionEncodeSurroundingInfo;\n    state.attentionEncodeSurroundingInfo = undefined;\n    encodeAfter = undefined;\n\n    // If we have to encode the first character before the current node and\n    // it’s still the same character,\n    // encode it.\n    if (encodingInfo) {\n      if (results.length > 0 && encodingInfo.before && before === results[results.length - 1].slice(-1)) {\n        results[results.length - 1] = results[results.length - 1].slice(0, -1) + encodeCharacterReference(before.charCodeAt(0));\n      }\n      if (encodingInfo.after) encodeAfter = after;\n    }\n    tracker.move(value);\n    results.push(value);\n    before = value.slice(-1);\n  }\n  indexStack.pop();\n  return results.join('');\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}