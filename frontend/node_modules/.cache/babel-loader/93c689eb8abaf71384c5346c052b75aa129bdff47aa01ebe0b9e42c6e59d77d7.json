{"ast":null,"code":"/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {InlineCode, Parents} from 'mdast'\n */\n\ninlineCode.peek = inlineCodePeek;\n\n/**\n * @param {InlineCode} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @returns {string}\n */\nexport function inlineCode(node, _, state) {\n  let value = node.value || '';\n  let sequence = '`';\n  let index = -1;\n\n  // If there is a single grave accent on its own in the code, use a fence of\n  // two.\n  // If there are two in a row, use one.\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n    sequence += '`';\n  }\n\n  // If this is not just spaces or eols (tabs don’t count), and either the\n  // first or last character are a space, eol, or tick, then pad with spaces.\n  if (/[^ \\r\\n]/.test(value) && (/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value) || /^`|`$/.test(value))) {\n    value = ' ' + value + ' ';\n  }\n\n  // We have a potential problem: certain characters after eols could result in\n  // blocks being seen.\n  // For example, if someone injected the string `'\\n# b'`, then that would\n  // result in an ATX heading.\n  // We can’t escape characters in `inlineCode`, but because eols are\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\n  // them out.\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index];\n    const expression = state.compilePattern(pattern);\n    /** @type {RegExpExecArray | null} */\n    let match;\n\n    // Only look for `atBreak`s.\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\n    // CR.\n    if (!pattern.atBreak) continue;\n    while (match = expression.exec(value)) {\n      let position = match.index;\n\n      // Support CRLF (patterns only look for one of the characters).\n      if (value.charCodeAt(position) === 10 /* `\\n` */ && value.charCodeAt(position - 1) === 13 /* `\\r` */) {\n        position--;\n      }\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1);\n    }\n  }\n  return sequence + value + sequence;\n}\n\n/**\n * @returns {string}\n */\nfunction inlineCodePeek() {\n  return '`';\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}